<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://fonts.loli.net" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/lin2-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/lin2-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLobster+Two:300,300italic,400,400italic,700,700italic%7CEB+Garamond:300,300italic,400,400italic,700,700italic%7CMeta+-+Meta:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"time_wait.gitee.io","root":"/","images":"/images","scheme":"Gemini","version":"8.3.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="使用线程  实现 Runnable 接口 需要实现 run() 方法 1234567891011121314151617181920public class Task implements Runnable &amp;#123;    @Override    public void run() &amp;#123;        for (int i &#x3D; 0; i &lt; 1000; i++) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="并发基础">
<meta property="og:url" content="http://time_wait.gitee.io/archives/46bf65ac.html">
<meta property="og:site_name" content="Time_Wait">
<meta property="og:description" content="使用线程  实现 Runnable 接口 需要实现 run() 方法 1234567891011121314151617181920public class Task implements Runnable &amp;#123;    @Override    public void run() &amp;#123;        for (int i &#x3D; 0; i &lt; 1000; i++) &amp;#123;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://time_wait.gitee.io/archives/46bf65ac/ThreadLocalMap.png">
<meta property="og:image" content="http://time_wait.gitee.io/archives/46bf65ac/%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png">
<meta property="article:published_time" content="2021-05-21T14:51:09.000Z">
<meta property="article:modified_time" content="2021-05-23T08:44:47.636Z">
<meta property="article:author" content="Time_Wait">
<meta property="article:tag" content="线程池">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="线程状态">
<meta property="article:tag" content="线程同步">
<meta property="article:tag" content="线程协作">
<meta property="article:tag" content="J.U.C 构件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://time_wait.gitee.io/archives/46bf65ac/ThreadLocalMap.png">


<link rel="canonical" href="http://time_wait.gitee.io/archives/46bf65ac.html">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>并发基础 | Time_Wait</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Time_Wait</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text"> 使用线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-runnable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text"> 实现 Runnable 接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-callable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text"> 实现 Callable 接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-thread-%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text"> 继承 Thread 类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text"> 线程基本机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.</span> <span class="nav-text"> 线程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">4.</span> <span class="nav-text"> 线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized"><span class="nav-number">4.1.</span> <span class="nav-text"> synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">4.1.1.</span> <span class="nav-text"> synchronized 基本使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.2.</span> <span class="nav-text"> synchronized 的实现原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized-%E4%BC%98%E5%8C%96"><span class="nav-number">4.1.3.</span> <span class="nav-text"> synchronized 优化</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reentrantlock"><span class="nav-number">4.2.</span> <span class="nav-text"> ReentrantLock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized-%E5%92%8C-reentrantlock-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">4.3.</span> <span class="nav-text"> synchronized 和 ReentrantLock 的比较</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text"> 线程协作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.</span> <span class="nav-text"> 生产者消费者问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">6.</span> <span class="nav-text"> 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-number">6.1.</span> <span class="nav-text"> 不可变</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="nav-number">6.2.</span> <span class="nav-text"> 互斥同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5"><span class="nav-number">6.3.</span> <span class="nav-text"> 非阻塞同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#threadlocal"><span class="nav-number">6.4.</span> <span class="nav-text"> ThreadLocal</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#juc-%E4%B8%AD%E7%9A%84%E6%9E%84%E4%BB%B6"><span class="nav-number">7.</span> <span class="nav-text"> J.U.C 中的构件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#countdownlatch"><span class="nav-number">7.1.</span> <span class="nav-text"> CountDownLatch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cyclicbarrier"><span class="nav-number">7.2.</span> <span class="nav-text"> CyclicBarrier</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#semaphore"><span class="nav-number">7.3.</span> <span class="nav-text"> Semaphore</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#blockingqueue"><span class="nav-number">7.4.</span> <span class="nav-text"> BlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#forkjoin"><span class="nav-number">7.5.</span> <span class="nav-text"> ForkJoin</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aqs"><span class="nav-number">8.</span> <span class="nav-text"> AQS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cas"><span class="nav-number">9.</span> <span class="nav-text"> CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text"> Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="nav-number">10.1.</span> <span class="nav-text"> 主内存与工作内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">10.2.</span> <span class="nav-text"> 内存间的交互操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">10.3.</span> <span class="nav-text"> 三大特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#happens-before"><span class="nav-number">10.4.</span> <span class="nav-text"> happens-before</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text"> 面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#start-%E5%92%8C-run-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.1.</span> <span class="nav-text"> start() 和 run() 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.2.</span> <span class="nav-text"> sleep() 和 wait() 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="nav-number">11.3.</span> <span class="nav-text"> 提交任务时，任务队列满了，会发生什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#volatile-%E6%95%B0%E7%BB%84"><span class="nav-number">11.4.</span> <span class="nav-text"> volatile 数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.5.</span> <span class="nav-text"> synchronized 和 volatile 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">11.6.</span> <span class="nav-text"> 悲观锁和乐观锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#threadlocal-%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">11.7.</span> <span class="nav-text"> ThreadLocal 造成内存泄漏的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linkedblockingqueue-%E5%85%A5%E9%98%9F%E5%87%BA%E9%98%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%81"><span class="nav-number">11.8.</span> <span class="nav-text"> LinkedBlockingQueue 入队出队为什么用不同的锁</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Time_Wait"
      src="/images/bear.jpeg">
  <p class="site-author-name" itemprop="name">Time_Wait</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>

<script type="text/javascript">
     var alltags = document.getElementsByClassName('tag-cloud-tags');
     var tags = alltags[0].getElementsByTagName('a');
     for (var i = tags.length - 1; i >= 0; i--) {
       var r=Math.floor(Math.random()*75+130);
       var g=Math.floor(Math.random()*75+100);
       var b=Math.floor(Math.random()*75+80);
       tags[i].style.background = "rgb("+r+","+g+","+b+")";
     }
</script>

<style>
  .tag-cloud-tags{
    /*font-family: Helvetica, Tahoma, Arial;*/
    /*font-weight: 100;*/
    text-align: center;
    counter-reset: tags;
  }
  .tag-cloud-tags a{
    border-radius: 6px;
    padding-right: 5px;
    padding-left: 5px;
    margin: 8px 5px 0px 0px;
  }
  .tag-cloud-tags a:before{
    content: "🔖";
  }

  .tag-cloud-tags a:hover{
     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);
     transform: scale(1.1);
     /*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/
     transition-duration: 0.15s;
  }
</style>


        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://time_wait.gitee.io/archives/46bf65ac.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/bear.jpeg">
      <meta itemprop="name" content="Time_Wait">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time_Wait">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并发基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-21 22:51:09" itemprop="dateCreated datePublished" datetime="2021-05-21T22:51:09+08:00">2021-05-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-05-23 16:44:47" itemprop="dateModified" datetime="2021-05-23T16:44:47+08:00">2021-05-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>21k</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h4 id="使用线程"><a class="markdownIt-Anchor" href="#使用线程"></a> 使用线程</h4>
<h5 id="实现-runnable-接口"><a class="markdownIt-Anchor" href="#实现-runnable-接口"></a> 实现 <code>Runnable</code> 接口</h5>
<p>需要实现 <code>run()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableDemo task = <span class="keyword">new</span> RunnableDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(task, <span class="string">&quot;线程&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程: i 和 main: i 会交替显示</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="实现-callable-接口"><a class="markdownIt-Anchor" href="#实现-callable-接口"></a> 实现 <code>Callable</code> 接口</h5>
<p>需要实现 <code>call()</code> 方法，与 <code>Runnable</code> 相比，<code>Callable</code> 有返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    String s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallableDemo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> CallableDemo(<span class="string">&quot;Callable&lt;String&gt;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程: i 和 main: i 会交替显示</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，实现 <code>Runnable</code> 或 <code>Callable</code> 接口的类本身并不具有线程行为，可以把这些类看作是执行某些任务的类，要使这些任务执行起来还是需要真正的线程来驱动。</p>
<h5 id="继承-thread-类"><a class="markdownIt-Anchor" href="#继承-thread-类"></a> 继承 <code>Thread</code> 类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>); <span class="comment">// 让线程休眠，更好地看到线程交替执行效果</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> ThreadDemo(<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>); <span class="comment">// 让线程休眠，更好地看到线程交替执行效果</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承 <code>Thread</code> 类与实现 <code>Runnable</code> 接口的比较：</p>
<ol>
<li>
<p>实现 <code>Runnable</code> 接口可以更好的解耦。</p>
<blockquote>
<p><code>Runnable</code> 只有一个 <code>run()</code> 方法，定义需要实现的任务;</p>
<p><code>Thread</code> 则负责线程的属性设置和启动等内容。</p>
</blockquote>
</li>
<li>
<p>在某些情况下，实现 <code>Runnable</code> 接口可以提高性能。</p>
<blockquote>
<p>使用继承 <code>Thread</code> 类的方式，每执行一次任务，都需要重新创建一个线程，等任务执行完，线程需要被销毁，增加了额外的开销；</p>
<p>使用实现 <code>Runnable</code> 接口的方式，在任务定义完之后，配合线程池，只需将任务传入线程池，使用线程池中固有的线程来执行任务，而不需要每次都创建销毁线程。</p>
</blockquote>
</li>
<li>
<p>Java 不支持多继承，如果继承了 <code>Thread</code> 类，之后就不能再继承其他类，限制了代码代码的可扩展性。</p>
</li>
</ol>
<h4 id="线程基本机制"><a class="markdownIt-Anchor" href="#线程基本机制"></a> 线程基本机制</h4>
<ul>
<li><strong>休眠（<code>sleep</code>）</strong></li>
</ul>
<p>调用 <code>sleep()</code> 不会释放对象锁。</p>
<p><code>sleep()</code> 可能会抛出 <code>InterruptedException</code>，因为异常不能跨线程传播，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>让步（<code>yield</code>）</strong></li>
</ul>
<p>给线程调度机制一个建议，当前线程的工作已经做得差不多了，可以把 <code>CPU</code> 让给其他线程，当前线程重新进入就绪状态。</p>
<p><code>yield()</code> 只是给一个建议，不一定会被采纳。</p>
<p>调用 <code>yield()</code> 不会释放对象锁。</p>
<ul>
<li>插<strong>队（<code>join</code>）</strong></li>
</ul>
<p>在 <code>A</code> 线程中调用 <code>B.join()</code>，<code>A</code> 线程将被挂起，直到 <code>B</code> 线程结束才恢复，<code>B</code> 线程是一个插队线程。</p>
<p>对 <code>join()</code> 的调用可以被中断，做法是调用插队线程的 <code>interrupt()</code> 方法。</p>
<ul>
<li><strong>中断（<code>interrupt</code>）</strong></li>
</ul>
<p>对于 <code>Java</code> 来说，停止线程的正确方式是调用线程的 <code>interrupt()</code> 方法。</p>
<p>调用线程的 <code>interrupt()</code> 方法，将设置线程的中断状态。如果一个线程已经被阻塞，或正试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出 <code>java.lang.InterruptedException</code> 异常。</p>
<p>为了调用 <code>interrupt()</code>，需要先持有 <code>Thread</code> 对象。新的 <code>concurrent</code> 类库中尽量在避免对 <code>Thread</code> 对象的直接操作，转而尽量通过 <code>Executor</code> 来执行所有操作。</p>
<p>如果在 <code>Executor</code> 上调用 <code>shutdownNow()</code>，将会发送一个 <code>interrupt()</code> 调用给它启动的所有线程。</p>
<p>如果希望只中断某个单一任务，可以通过 <code>submit()</code> 来启动任务，并持有任务的上下文。<code>submit()</code> 返回一个 <code>Future&lt;?&gt;</code>，可以在其上调用 <code>cancel()</code>，如果把 <code>true</code> 传给 <code>cancel()</code>，那么它就可以在该线程上调用 <code>interrupt()</code> 以停止这个线程。</p>
<p><code>I/O</code> 和在 <code>synchronized</code> 块上的阻塞是不可中断的。</p>
<p><code>interrupt()</code> 将会给线程设定一个中断标志，但中断一个阻塞的线程将抛出 <code>InterruptedException</code> 异常，该异常被捕获时将清除线程的中断标志，所以在 <code>catch</code> 子句中，在异常被捕获时这个标志总是为假。</p>
<h4 id="线程状态"><a class="markdownIt-Anchor" href="#线程状态"></a> 线程状态</h4>
<ul>
<li><code>NEW</code></li>
</ul>
<p>创建后还未启动的线程处于这个状态。</p>
<ul>
<li><code>RUNNABLE</code></li>
</ul>
<p>可运行（就绪）状态。可能正在运行，也可能在等待 <code>CPU</code> 调度。</p>
<ul>
<li><code>BLOCKED</code></li>
</ul>
<p>阻塞（等待获取一个对象锁）状态。</p>
<ul>
<li><code>WAITING</code></li>
</ul>
<p>无限期等待其他线程唤醒。</p>
<p>线程进入这种状态可能是调用了以下方法：</p>
<blockquote>
<ul>
<li><code>Object.wait()</code></li>
<li><code>Thread.join()</code></li>
<li><code>LockSupport.park()</code></li>
</ul>
</blockquote>
<ul>
<li><code>TIMED_WAITING</code></li>
</ul>
<p>在有限时间内等待其他线程执行某些操作。</p>
<p>线程进入这种状态可能是调用了以下方法：</p>
<blockquote>
<ul>
<li><code>Thread.sleep(long timeout)</code></li>
<li><code>Object.wait(long timeout)</code></li>
<li><code>Thread.join(long timeout)</code></li>
<li><code>LockSupport.parkNanos(long timeout)</code></li>
<li><code>LockSupport.parkUntil(long timeout)</code></li>
</ul>
</blockquote>
<ul>
<li><code>TERMINATED</code></li>
</ul>
<p>线程终止。</p>
<h4 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h4>
<p><code>Java</code> 有两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 <code>JVM</code> 实现的 <code>synchronized</code>，而另一个是 <code>JDK</code> 实现的 <code>ReentrantLock</code>。</p>
<h5 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> <code>synchronized</code></h5>
<h6 id="synchronized-基本使用"><a class="markdownIt-Anchor" href="#synchronized-基本使用"></a> <code>synchronized</code> 基本使用</h6>
<ul>
<li>同步代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同步方法</li>
</ul>
<p>锁定调用这个方法的对象 （this）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个线程在一个对象上调用了 <code>f()</code>，对于该对象而言，只有等到 <code>f()</code> 调用结束释放了对象锁，其他线程才能调用 <code>f()</code> 和 <code>g()</code>。也即是说，对于一个特定对象来说，其所有的 <code>synchronized</code> 方法共享同一个锁。</p>
<h6 id="synchronized-的实现原理"><a class="markdownIt-Anchor" href="#synchronized-的实现原理"></a> <code>synchronized</code> 的实现原理</h6>
<p><code>Java</code> 中每个对象都有一个 <code>monitor</code> 与之关联，当一个对象的 <code>monitor</code> 被获取后，该对象将处于锁定状态。</p>
<p>在 <code>Java</code> 虚拟机（<code>HotSpot</code>）中，<code>monitor</code> 是基于 <code>ObjectMonitor</code> 实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header       = NULL;</span><br><span class="line">  _count        = <span class="number">0</span>;</span><br><span class="line">  _waiters      = <span class="number">0</span>,</span><br><span class="line">  _recursions   = <span class="number">0</span>;  <span class="comment">// 锁的重入次数</span></span><br><span class="line">  _object       = NULL;</span><br><span class="line">  _owner        = NULL;  <span class="comment">// 持有对象 monitor 的线程</span></span><br><span class="line">  _WaitSet      = NULL;  <span class="comment">// 处于 wait 状态的线程队列</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = NULL ;</span><br><span class="line">  _succ         = NULL ;</span><br><span class="line">  _cxq          = NULL ;</span><br><span class="line">  FreeNext      = NULL ;</span><br><span class="line">  _EntryList    = NULL ;  <span class="comment">// 处于 blocked 状态的线程队列</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>多个线程同时访问一段同步代码时，线程进入 <code>_EntryList</code> 队列中；</p>
</li>
<li>
<p>某个线程获取到对象的 <code>monitor</code> 后，<code>_Owner</code> 指向当前线程，同时 <code>monitor</code> 中的计数器 <code>_count</code> 加1；</p>
</li>
<li>
<p>若持有 <code>monitor</code> 的线程在对象上调用 <code>wait()</code> 方法，将释放该对象 <code>monitor</code>，<code>_owner</code> 变量恢复为 <code>null</code>，<code>_count</code>自减1，同时该线程进入 <code>_WaitSet</code> 集合中等待被唤醒。</p>
</li>
</ul>
<h6 id="synchronized-优化"><a class="markdownIt-Anchor" href="#synchronized-优化"></a> <code>synchronized</code> 优化</h6>
<ul>
<li>自旋锁</li>
</ul>
<div class="note "><p>线程的阻塞和唤醒会使 <code>CPU</code> 从用户态陷入内核态，频繁的阻塞和唤醒操作对 <code>CPU</code> 来说是一项负担很重的工作，会影响并发度。</p>
<p>许多应用，对象锁的锁状态只会持续很短的一段时间。基于这个观察，引入<strong>自旋锁</strong>。所谓自旋锁，就是让线程自旋一段时间，等待锁被释放，这样可以避免让线程挂起（阻塞）。</p>
<p>自旋锁虽然避免了切换线程带来的开销，但自旋占用了 <code>CPU</code> 的时间。如果持有锁的线程很快释放了锁，自旋锁的效率就很高；反之，自旋的线程就会白白消耗处理器的资源，反而会降低性能。所以一般自旋需要限定一段时间或限定自旋的次数，超过规定的时间或次数，还没有获得锁的话就将自旋的线程挂起。</p>
</div>
<ul>
<li>适应性自旋锁</li>
</ul>
<div class="note "><p>适应性自旋锁的工作原理大概是这样的：</p>
<p>对于某个锁，如果自旋成功，那么下次在获取该锁时就会自旋更久，因为虚拟机认为既然上次自旋成功，那么这次自旋也很可能会成功；</p>
<p>反之，如果对于某个锁的获取很少自旋成功，那么下次获取该锁时就自旋很少的时间或在压根不自旋，直接挂起线程，以免自旋浪费时间。</p>
</div>
<ul>
<li>锁消除</li>
</ul>
<div class="note "><p>在有些情况下，如果 <code>JVM</code> 检测到不会有共享数据竞争的问题，就会对其中的同步锁进行消除，节省请求锁的时间。</p>
</div>
<ul>
<li>锁粗化</li>
</ul>
<div class="note "><p>在使用同步锁时，经常需要让同步的作用范围尽可能小，这样同步块内的代码量少，如果存在锁竞争，持有锁的线程能尽快执行完同步块内的代码并释放锁，请求锁的线程也可以尽快地获取锁。</p>
<p>通常这是同步代码的指导原则，但是也有一种情况是，因为加锁和释放锁的操作比较耗时，如果<strong>连续多处有同步代码块</strong>，此时可以考虑将锁的作用范围扩大，将多个加锁的代码块合并为一个，从而减少加锁和解锁操作。</p>
</div>
<ul>
<li>偏向锁</li>
</ul>
<div class="note "><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次 <code>CAS</code> 原子指令的。</p>
<p>使用偏向锁只需要检查是否为偏向锁、锁标识为以及 <code>ThreadID</code> 即可。</p>
</div>
<ul>
<li>轻量级锁</li>
</ul>
<div class="note "><p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p>
</div>
<h5 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> <code>ReentrantLock</code></h5>
<p><strong><code>ReentrantLock</code> 基本使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// ... method body</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="synchronized-和-reentrantlock-的比较"><a class="markdownIt-Anchor" href="#synchronized-和-reentrantlock-的比较"></a> <code>synchronized</code> 和 <code>ReentrantLock</code> 的比较</h5>
<ul>
<li>
<p><code>synchronized</code> 是 <code>JVM</code> 实现的，<code>ReentrantLock</code> 是 <code>JDK</code> 实现的；</p>
</li>
<li>
<p><code>ReentrantLock</code> 阻塞可中断， <code>synchronized</code> 阻塞不可中断；</p>
</li>
<li>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来依次获得锁。</p>
<p><code>synchronized</code> 锁是非公平的，<code>ReentrantLock</code> 默认也是非公平的，但是可以设置为公平的;</p>
</li>
<li>
<p><code>ReentrantLock</code> 可以同时绑定定多个 <code>Condition</code> 对象；</p>
</li>
<li>
<p>除非需要使用 <code>ReentrantLock</code> 的高级功能，否则<strong>优先使用 <code>synchronized</code></strong>。</p>
</li>
</ul>
<h4 id="线程协作"><a class="markdownIt-Anchor" href="#线程协作"></a> 线程协作</h4>
<p><strong>信号丢失</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1</span></span><br><span class="line"><span class="keyword">synchronized</span> (sharedMonitor) &#123;</span><br><span class="line">  	&lt;setup condition <span class="keyword">for</span> T2&gt;</span><br><span class="line">    sharedMonitor.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T2</span></span><br><span class="line"><span class="keyword">while</span> (someCondition) &#123;</span><br><span class="line">  	<span class="comment">// point1</span></span><br><span class="line">    <span class="keyword">synchronized</span> (sharedMonitor) &#123;</span><br><span class="line">      	sharedMonitor.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>T2</code> 先执行，并发现 <code>someCondition</code> 为 <code>true</code>，在 <code>point1</code>，<code>CPU</code> 切换到 <code>T1</code>。</p>
<p><code>T1</code> 执行设置，然后调用 <code>notify()</code>。当 <code>T2</code> 被重新调度，获得 <code>shareMonitor</code> 后继续执行进入 <code>wait()</code>，并释放 <code>shareMonitor</code>。</p>
<p>但是因为 <code>T1</code> 已经执行完毕，不会再调用 <code>notify()</code>，<code>T2</code> 将一直等待这个已经发送过的信号，从而产生死锁。</p>
<p>产生这个问题的原因是在 <code>someCondition</code> 发生了<strong>竞争条件</strong>，<code>T1</code> 和 <code>T2</code> 能否正常协作，取决于 <code>someCondition</code> 的设置和判断顺序。</p>
<p>解决方法是消除在 <code>someCondition</code> 上的竞争条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T2</span></span><br><span class="line"><span class="keyword">synchronized</span> (sharedMonitor) &#123;</span><br><span class="line">  	<span class="keyword">while</span> (someCondition) &#123;</span><br><span class="line">      	sharedMonitor.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，使用 <code>wait()</code> 的安全方式正是在上述这种方式，在同步代码块中，使用 <code>while</code> 等待某种条件生效。</p>
<p><strong>虚假唤醒</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">   <span class="keyword">if</span> (&lt;condition does not hold&gt;)</span><br><span class="line">       obj.wait(); <span class="comment">// point1</span></span><br><span class="line">   <span class="comment">// point2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，假设有 2 个线程 <code>T1</code> 和 <code>T2</code> 先后获取 <code>obj</code> 对象锁后，<code>if</code> 判断都为假，<code>T1</code> 、<code>T2</code> 进入阻塞状态；</p>
<p>然后有另一个线程 <code>T3</code> 获取了 <code>obj</code> 对象后将 <code>condition</code> 设置为 <code>true</code> ，并调用 <code>notify()</code>，同时唤醒 <code>T1</code>、<code>T2</code>；</p>
<p>假设 <code>T1</code> 竞争获得 <code>obj</code> 对象锁，不会重新判断 <code>condition</code>，而是接着执行 <code>point2</code> 处代码，然后结束允许并释放锁；</p>
<p>最后，<code>T2</code> 终重新获得 <code>obj</code> 对象锁，同样不会重新判断 <code>condition</code>，并接着执行 <code>point2</code> 处代码。如果 <code>T1</code> 执行完后 <code>condition</code> 又为假，<code>T2</code> 因为没有重新判断条件，再执行后续代码就出错了。</p>
<p>这就是虚假唤醒所导致的问题，正确的写法是将 <code>condtion</code> 放在 <code>while</code> 循环里，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">   <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">       obj.wait(); <span class="comment">// point1</span></span><br><span class="line">   <span class="comment">// point2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就保证了，线程从 <code>wait()</code> 中返回（被唤醒）后，不会直接执行 <code>point2</code> 处代码，而是接着判断 <code>condition</code>，如果条件不满足，接着进入阻塞状态，保证并发的正确执行。</p>
<h5 id="生产者消费者问题"><a class="markdownIt-Anchor" href="#生产者消费者问题"></a> 生产者消费者问题</h5>
<ul>
<li><strong>使用 <code>BlockingQueue</code> 实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueuePC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 这个程序不会自动停止，添加一个 Timer，以便在 100 毫秒后停止</span></span><br><span class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Aborting&quot;</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义生产任务</span></span><br><span class="line">        Runnable producer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce the &quot;</span> + queue.size() + <span class="string">&quot;th Object&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(producer, <span class="string">&quot;Producer1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(producer, <span class="string">&quot;Producer2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义消费任务</span></span><br><span class="line">        Runnable consumer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume the &quot;</span> + queue.size() + <span class="string">&quot;th Object&quot;</span>);</span><br><span class="line">                    queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建两个消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(consumer, <span class="string">&quot;Consumer1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer, <span class="string">&quot;Consumer2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用 <code>wait + notify/notifyAll</code> 实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义简单队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果容器满了，就阻塞生产者</span></span><br><span class="line">        <span class="keyword">while</span> (storage.size() == capacity) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        storage.add(<span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒消费者</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果容器为空，就阻塞消费者</span></span><br><span class="line">        <span class="keyword">while</span> (storage.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object o = storage.remove();</span><br><span class="line">        <span class="comment">// 唤醒生产者</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyBlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(MyBlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                storage.produce();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce &quot;</span> + i);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyBlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(MyBlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                storage.consume();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume &quot;</span> + i);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用 <code>await + signal/signalAll</code> 实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 定义两个 Condition</span></span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容器满了，阻塞生产者，等待唤醒</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            queue.add(o);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒消费者</span></span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object o = queue.remove();</span><br><span class="line">            notFull.signalAll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者、消费者代码类似。</p>
<h4 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h4>
<p>保证线程安全的方法有以下几种方式。</p>
<h5 id="不可变"><a class="markdownIt-Anchor" href="#不可变"></a> 不可变</h5>
<p>不可变的对象一定是线程安全的，只要一个不可变的对象被正确地构建出来，就不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变类型：</p>
<ul>
<li><code>final</code> 修饰的基本数据类型</li>
<li><code>String</code></li>
<li>枚举类型</li>
<li><code>Number</code> 部分子类</li>
</ul>
<h5 id="互斥同步"><a class="markdownIt-Anchor" href="#互斥同步"></a> 互斥同步</h5>
<p>即使用 <code>synchronized</code> 或 <code>ReentrantLock</code> 对访问共享资源的代码加锁。</p>
<h5 id="非阻塞同步"><a class="markdownIt-Anchor" href="#非阻塞同步"></a> 非阻塞同步</h5>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，互斥同步称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，认为只要不做正确的同步措施，就肯定会出现问题。所以无论共享数据是否真的会出现竞争，都要进行加锁。</p>
<p>与悲观并发策略相对的是乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>可以用 <code>CAS</code> 实现非阻塞同步。</p>
<h5 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> <code>ThreadLocal</code></h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ThreadLocal</code> 的底层数据结构：</p>
<p><img data-src="/archives/46bf65ac/ThreadLocalMap.png" alt="ThreadLocalMap"></p>
<p>每个 <code>Thread</code> 都有一个 <code>ThreadLocal.ThreadLocalMap</code> 对象。</p>
<p>当调用一个 <code>ThreadLocal</code> 的 <code>set(T value)</code> 方法时，先得到当前线程的 <code>ThreadLocalMap</code> 对象，然后将 <code>ThreadLocal-&gt;value</code> 键值对插入到该 <code>Map</code> 中。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 <code>ThreadLocal.ThreadLocalMap</code> 的底层数据结构导致 <code>ThreadLocal</code> 有内存泄漏的情况，应该尽可能在每次使用 <code>ThreadLocal</code> 后手动调用 <code>remove()</code>，以避免出现 <code>ThreadLocal</code> 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h4 id="juc-中的构件"><a class="markdownIt-Anchor" href="#juc-中的构件"></a> <code>J.U.C</code> 中的构件</h4>
<h5 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> <code>CountDownLatch</code></h5>
<p>用来同步多个任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">     <span class="comment">// 主线程做完准备工作后，调用 startSignal 的 countDown()，通知在 startSignal 上等待的   </span></span><br><span class="line">     <span class="comment">// 线程可以开始工作了</span></span><br><span class="line">     startSignal.countDown();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 主线程在做收尾工作前，在 doneSignal 上等待</span></span><br><span class="line">     doneSignal.await(); </span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">     <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       startSignal.await(); <span class="comment">// 启动这个任务的线程会在 startSignal 上等待</span></span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">       doneSignal.countDown(); <span class="comment">// 所有线程执行完后，在 doneSignal 上等待的线程才能执行</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> <code>CyclicBarrier</code></h5>
<p><code>CyclicBarrier</code> 适用于这样的情况：你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所以任务都完成。<code>CyclicBarrier</code> 使得所有的并行任务都将在栅栏处列队，然后再一致地向前移动。</p>
<p><code>CyclicBarrier</code> 作用类似于 <code>CountDownLatch</code>，只是 <code>CountDownLatch</code> 只能触发一次，而 <code>CyclicBarrier</code> 通过调用 <code>reset()</code> 可以重复使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1</span></span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// 每个线程在执行完 1 处代码会等待，直到其他所有线程执行完 1 处代码才会再执行 2 处代码</span></span><br><span class="line">                    <span class="comment">// 2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        cyclicBarrier.reset();</span><br><span class="line"></span><br><span class="line">        System.out.println(cyclicBarrier.getParties()); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> <code>Semaphore</code></h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">      	<span class="comment">// 信号量控制最多只有 clientCount 并发执行</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="blockingqueue"><a class="markdownIt-Anchor" href="#blockingqueue"></a> <code>BlockingQueue</code></h5>
<p><code>BlockingQueue</code> 主要用在生产者消费者场景，在以下情况访问 <code>BlockingQueue</code> 会造成阻塞：</p>
<ul>
<li><code>BlockingQueue</code> 已满的情况下进行入队操作</li>
<li><code>BlockingQueue</code> 为空的情况下进行出队操作</li>
</ul>
<p><code>BlockingQueue</code> 有不同的方法进行入队、出队操作：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:center">返回布尔值</th>
<th style="text-align:center">阻塞</th>
<th style="text-align:center">限时等待</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Insert</code></td>
<td style="text-align:center"><code>add(e)</code></td>
<td style="text-align:center"><code>offer(e)</code></td>
<td style="text-align:center"><code>put(e)</code></td>
<td style="text-align:center"><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Remove</code></td>
<td style="text-align:center"><code>remove()</code></td>
<td style="text-align:center"><code>poll()</code></td>
<td style="text-align:center"><code>take()</code></td>
<td style="text-align:center"><code>poll(time, unit)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Examine</code></td>
<td style="text-align:center"><code>element()</code></td>
<td style="text-align:center"><code>peek()</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>其中限时等待操作在到时后返回 <code>true</code> 或 <code>false</code> 。</p>
<p><code>BlockingQueue</code> 主要实现类：</p>
<ul>
<li><code>ArrayBlockingQueue</code></li>
</ul>
<p>基于数组实现的有界阻塞队列。</p>
<p>可以执行线程访问队列的策略，默认为非公平访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 入队元素 */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个 take, poll, peek 或 remove 的元素下标 */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个 put, offer, 或 add 的元素下标 */</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 队列中元素个数 */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 等待 takes 的 Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 等待 puts 的 Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Throws:</span></span><br><span class="line"><span class="comment">InterruptedException</span></span><br><span class="line"><span class="comment">NullPointerException */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e); <span class="comment">// 检查入队元素是否非空</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await(); <span class="comment">// 如果队列已满，线程阻塞，在 notFull 上等待唤醒</span></span><br><span class="line">        enqueue(e); <span class="comment">// 真正的入队操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkNotNull</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal(); <span class="comment">// 入队一个元素，队列非空，唤醒在 notEmpty 上等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await(); <span class="comment">// 队列为空，线程阻塞，在 notEmpty 上等待唤醒</span></span><br><span class="line">        <span class="keyword">return</span> dequeue(); <span class="comment">// 出队</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued(); <span class="comment">// 更新 iterator</span></span><br><span class="line">    notFull.signal(); <span class="comment">// 队列未满，唤醒在 notFull 上等待的线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>LinkedBlockingQueue</code></li>
</ul>
<p>基于链表实现的阻塞队列，默认队列长度是 <code>Integer.MAX_VALUE</code>，可以执行队列大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 容量, 默认 Integer.MAX_VALUE */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 元素个数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表头</span></span><br><span class="line"><span class="comment">     * Invariant: head.item == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表尾</span></span><br><span class="line"><span class="comment">     * Invariant: last.next == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 入队锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 出队锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<p>入队：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123; <span class="comment">// 队列已满</span></span><br><span class="line">            notFull.await(); <span class="comment">// 线程阻塞，在 notFull 上等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node); <span class="comment">// 入队</span></span><br><span class="line">        c = count.getAndIncrement(); <span class="comment">// count + 1</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">// 队列为空</span></span><br><span class="line">            notEmpty.await(); <span class="comment">// 线程阻塞，在 notEmpty 上阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue(); <span class="comment">// 出队</span></span><br><span class="line">        c = count.getAndDecrement(); <span class="comment">// count - 1</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>PriorityBlockingQueue</code></li>
<li><code>DelayQueue</code></li>
</ul>
<h5 id="forkjoin"><a class="markdownIt-Anchor" href="#forkjoin"></a> ForkJoin</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            ForkJoinDemo leftTask = <span class="keyword">new</span> ForkJoinDemo(threshold, first, middle);</span><br><span class="line">            leftTask.fork();</span><br><span class="line"></span><br><span class="line">            ForkJoinDemo rightTask = <span class="keyword">new</span> ForkJoinDemo(threshold, middle + <span class="number">1</span>, last);</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinDemo example = <span class="keyword">new</span> ForkJoinDemo(<span class="number">5</span>, <span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// ForkJoinPool 是一个特殊的线程池，线程数量取决于 CPU 核数</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        Future result = forkJoinPool.submit(example);</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> <code>AQS</code></h4>
<p>队列同步器（<code>AbstractQueuedSynchronizer</code>，<code>AQS</code>）是构建锁（<code>ReentrantLock</code>）或其他同步组件（<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code> 等）的基础框架。</p>
<h4 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> <code>CAS</code></h4>
<p>比较并交换（Compare-and-Swap，<code>CAS</code>）。<code>CAS</code> 指令需要有 3 个操作数，分别是内存地址 <code>V</code>、旧的预期值 <code>A</code> 和新值 <code>B</code>。当执行操作时，只有当 <code>V</code> 的值等于 <code>A</code>，才将 <code>V</code> 的值更新为 <code>B</code>。</p>
<p>问题：</p>
<ul>
<li><code>ABA</code> 问题</li>
<li>自旋消耗资源</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
<h4 id="java内存模型"><a class="markdownIt-Anchor" href="#java内存模型"></a> Java内存模型</h4>
<p><code>Java</code> 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 <code>Java</code> 程序在各种平台下都能达到一致的内存访问效果。</p>
<h5 id="主内存与工作内存"><a class="markdownIt-Anchor" href="#主内存与工作内存"></a> 主内存与工作内存</h5>
<p><code>CPU</code> 寄存器的读写速度比内存快几个数量级，为了缓解这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>但是加入高速缓存带来了一个新的问题：<strong>缓存一致性</strong>。</p>
<p>在并发环境中，通常多个线程需要共享主内存中的数据；每个线程有自己的工作内存，线程只能只能操作自己工作内存中的数据，因此需要将主内存中的数据拷贝到工作内存。</p>
<h5 id="内存间的交互操作"><a class="markdownIt-Anchor" href="#内存间的交互操作"></a> 内存间的交互操作</h5>
<p><img data-src="/archives/46bf65ac/%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="内存间交互操作"></p>
<ul>
<li>read：把一个变量的值从主内存读到工作内存</li>
<li>load：把读到的值放入工作内存的变量副本</li>
<li>use：使用变量副本</li>
<li>assign：把一个新值赋给工作内存的变量副本</li>
<li>store：把工作内存中变量副本的值存到主内存</li>
<li>write：把值写入主内存中的变量</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h5 id="三大特性"><a class="markdownIt-Anchor" href="#三大特性"></a> 三大特性</h5>
<ul>
<li>
<p><strong>原子性</strong></p>
<p>使用继承 <code>Number</code> 类的原子类或者 <code>synchronized</code> 可以保证操作的原子性</p>
</li>
<li>
<p><strong>可见性</strong></p>
<p>一个线程对共享变量的修改，其他线程立刻可见。</p>
<p>使用 <code>volatile</code> 或 <code>synchronized</code> 来保证可见性。</p>
</li>
<li>
<p><strong>有序性</strong></p>
<p>在 <code>Java</code> 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p><code>volatile</code> 关键字通过添加<strong>内存屏障</strong>的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前；也可以通过 <code>synchronized</code> 来保证有序性。</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>使用 <code>synchronized</code> 可以同时保证三大特性</li>
<li><code>volatile</code> 只能保证可见性，无法保证原子性</li>
</ul>
<h5 id="happens-before"><a class="markdownIt-Anchor" href="#happens-before"></a> happens-before</h5>
<p>除了可以用 <code>volatile</code> 和 <code>synchronized</code> 来保证有序性之外，<code>JVM</code> 还规定了先行发生原则（happens-before），让一个操作无需控制就能先于另一个操作完成。</p>
<ul>
<li>
<p>单一线程原则</p>
</li>
<li>
<p>管程锁定原则</p>
<blockquote>
<p>一个 <code>unlock</code> 操作先行发生于后面对同一个锁的 <code>lock</code> 操作。</p>
</blockquote>
</li>
<li>
<p><code>volatile</code> 变量原则</p>
<blockquote>
<p>对一个 <code>volatile</code> 变量的写操作先行发生于后面对这个变量的读操作。</p>
</blockquote>
</li>
<li>
<p>线程启动原则</p>
</li>
<li>
<p>线程加入原则</p>
</li>
<li>
<p>线程中断原则</p>
</li>
<li>
<p>对象终结原则</p>
</li>
<li>
<p>传递性原则</p>
</li>
</ul>
<h4 id="面试题"><a class="markdownIt-Anchor" href="#面试题"></a> 面试题</h4>
<h5 id="start-和-run-的区别"><a class="markdownIt-Anchor" href="#start-和-run-的区别"></a> <code>start()</code> 和 <code>run()</code> 的区别</h5>
<h5 id="sleep-和-wait-的区别"><a class="markdownIt-Anchor" href="#sleep-和-wait-的区别"></a> <code>sleep()</code> 和 <code>wait()</code> 的区别</h5>
<ul>
<li><code>wait</code> 是 <code>Object</code> 类中的方法，<code>sleep</code> 是 <code>Thread</code>类中的方法；</li>
<li><code>wai</code>t 会释放锁，<code>sleep</code> 不会释放锁；</li>
<li><code>wait</code> 只能在同步代码块中使用，<code>sleep</code> 则没有这个要求。</li>
</ul>
<h5 id="提交任务时任务队列满了会发生什么"><a class="markdownIt-Anchor" href="#提交任务时任务队列满了会发生什么"></a> 提交任务时，任务队列满了，会发生什么</h5>
<h5 id="volatile-数组"><a class="markdownIt-Anchor" href="#volatile-数组"></a> <code>volatile</code> 数组</h5>
<h5 id="synchronized-和-volatile-的区别"><a class="markdownIt-Anchor" href="#synchronized-和-volatile-的区别"></a> <code>synchronized</code> 和 <code>volatile</code> 的区别</h5>
<h5 id="悲观锁和乐观锁"><a class="markdownIt-Anchor" href="#悲观锁和乐观锁"></a> 悲观锁和乐观锁</h5>
<ul>
<li>悲观锁</li>
</ul>
<div class="note "><p>悲观的并发策略，认为只要不做正确的同步措施，就肯定会出现问题。所以无论共享数据是否真的会出现竞争，都要进行加锁。</p>
</div>
<ul>
<li>乐观锁</li>
</ul>
<h5 id="threadlocal-造成内存泄漏的原因"><a class="markdownIt-Anchor" href="#threadlocal-造成内存泄漏的原因"></a> <code>ThreadLocal</code> 造成内存泄漏的原因</h5>
<h5 id="linkedblockingqueue-入队出队为什么用不同的锁"><a class="markdownIt-Anchor" href="#linkedblockingqueue-入队出队为什么用不同的锁"></a> <code>LinkedBlockingQueue</code> 入队出队为什么用不同的锁</h5>

    </div>

    
    
    
      
  <div class="popular-posts-header">Related Posts</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/archives/de7c53fe.html" rel="bookmark">线程池</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>Time_Wait
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://time_wait.gitee.io/archives/46bf65ac.html" title="并发基础">http://time_wait.gitee.io/archives/46bf65ac.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag"><i class="fa fa-tag"></i> 线程池</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/" rel="tag"><i class="fa fa-tag"></i> 线程状态</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" rel="tag"><i class="fa fa-tag"></i> 线程同步</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/" rel="tag"><i class="fa fa-tag"></i> 线程协作</a>
              <a href="/tags/J-U-C-%E6%9E%84%E4%BB%B6/" rel="tag"><i class="fa fa-tag"></i> J.U.C 构件</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/58b717aa.html" rel="prev" title="Java容器">
                  <i class="fa fa-chevron-left"></i> Java容器
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/archives/66c016fb.html" rel="next" title="JVM">
                  JVM <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Time_Wait</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">2:43</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>





  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  


</body>
</html>
